import 'package:lottie/lottie.dart';
import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:pet_care/ColorsScheme.dart';
import 'package:pet_care/services/gemini_meal_service.dart';
import 'package:pet_care/HomePage/EditPetForm.dart';
import 'package:pet_care/AIScreen/AIMealPlanScreen.dart' as ai_meal;
import 'package:pet_care/widgets/meal_plan_display.dart';

class ManageSubscriptionScreen extends StatefulWidget {
  final Map<String, dynamic> subscription;
  final Map<String, dynamic> userData;

  const ManageSubscriptionScreen({
    super.key,
    required this.subscription,
    required this.userData,
  });

  @override
  State<ManageSubscriptionScreen> createState() => _ManageSubscriptionScreenState();
}

class _ManageSubscriptionScreenState extends State<ManageSubscriptionScreen> {
  Map<String, dynamic>? currentMeal;
  bool isLoading = true;
  bool isGeneratingMeal = false;
  bool isEditingMeal = false;
  String? errorMessage;
  
  @override
  void initState() {
    super.initState();
    _loadCurrentMeal();
    _autoSendNextMealIfDue();
  }

  /// Automatically send the same meal to order review if interval has passed and user hasn't sent a new meal
  Future<void> _autoSendNextMealIfDue() async {
    final subscription = widget.subscription;
    final status = subscription['status'] ?? 'pending';
    final isApproved = status == 'approved';
    final isCancelled = status == 'cancelled' || status == 'admin_cancelled';
    if (!isApproved || isCancelled) return;

    final deliveryDateStr = subscription['lastDeliveryDate'];
    if (deliveryDateStr == null) return;
    DateTime? lastDeliveryDate;
    try {
      lastDeliveryDate = DateTime.parse(deliveryDateStr);
    } catch (_) {
      return;
    }

    final frequency = subscription['frequency']?.toString().toLowerCase() ?? '1x';
    int intervalDays = frequency.contains('2x') ? 3 : 7;
    final now = DateTime.now();
    final nextMealDue = lastDeliveryDate.add(Duration(days: intervalDays));

    // Check if next meal is due and not already sent (by checking order_review for this cycle)
    if (now.isAfter(nextMealDue)) {
      // Check if an order_review exists for this cycle
      final orderReviewQuery = await FirebaseFirestore.instance
          .collection('order_review')
          .where('subscriptionId', isEqualTo: subscription['id'])
          .where('cycleStart', isEqualTo: nextMealDue.toIso8601String())
          .get();
      if (orderReviewQuery.docs.isEmpty && currentMeal != null) {
        // No order for this cycle, send the same meal
        await FirebaseFirestore.instance.collection('order_review').add({
          'meal': currentMeal,
          'subscriptionId': subscription['id'],
          'userId': subscription['userId'],
          'petId': subscription['petId'],
          'requestedAt': now.toIso8601String(),
          'cycleStart': nextMealDue.toIso8601String(),
          'status': 'pending',
          'frequency': subscription['frequency'],
          'autoGenerated': true,
        });
      }
    }
  }

  /// Load the current meal associated with the subscription
  Future<void> _loadCurrentMeal() async {
    setState(() {
      isLoading = true;
      errorMessage = null;
    });

    try {
      if (widget.subscription['mealId'] != null) {
        DocumentSnapshot mealDoc = await FirebaseFirestore.instance
            .collection('meals')
            .doc(widget.subscription['mealId'])
            .get();
        
        if (mealDoc.exists) {
          setState(() {
            currentMeal = mealDoc.data() as Map<String, dynamic>;
            currentMeal!['id'] = mealDoc.id;
          });
        }
      }
    } catch (e) {
      setState(() {
        errorMessage = 'Failed to load current meal: $e';
      });
    } finally {
      setState(() {
        isLoading = false;
      });
    }
  }

  /// Generate a new AI meal
  Future<void> _generateNewMeal() async {
    setState(() {
      isGeneratingMeal = true;
      errorMessage = null;
    });

    try {
      // Get pet data for meal generation
      Map<String, dynamic> petData = await _getPetData();
      
      // Generate new meal using Gemini services
      Map<String, dynamic>? newMealData = await GeminiMealService.generateOptimalPersonalizedMealWithData(
        petData: petData,
      );

      if (newMealData != null && !newMealData.containsKey('error')) {
        // Save the new meal to Firestore
        DocumentReference mealRef = await FirebaseFirestore.instance
            .collection('meals')
            .add({
          ...newMealData,
          'createdAt': DateTime.now().toIso8601String(),
          'subscriptionId': widget.subscription['id'],
          'petId': widget.subscription['petId'],
          'userId': widget.subscription['userId'],
        });

        // Update subscription with new meal ID
        await FirebaseFirestore.instance
            .collection('subscriptions')
            .doc(widget.subscription['id'])
            .update({
          'mealId': mealRef.id,
          'lastMealGenerated': DateTime.now().toIso8601String(),
        });

        // Reload current meal
        await _loadCurrentMeal();

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('âœ… New AI meal generated successfully!'),
            backgroundColor: Colors.green,
          ),
        );
      } else {
        setState(() {
          errorMessage = newMealData?['error'] ?? 'Failed to generate meal';
        });
      }
    } catch (e) {
      setState(() {
        errorMessage = 'Error generating meal: $e';
      });
    } finally {
      setState(() {
        isGeneratingMeal = false;
      });
    }
  }

  /// Get pet data for meal generation
  Future<Map<String, dynamic>> _getPetData() async {
    try {
      // Fetch pet data from the user's collection
      String userEmail = widget.userData['Email'] ?? widget.userData['uid'] ?? '';
      String petId = widget.subscription['petId'] ?? '';

      QuerySnapshot petQuery = await FirebaseFirestore.instance
          .collection(userEmail)
          .where('Email', isEqualTo: petId)
          .get();

      if (petQuery.docs.isNotEmpty) {
        Map<String, dynamic> petData = petQuery.docs.first.data() as Map<String, dynamic>;
        
        // Add subscription-specific data
        petData['subscriptionFrequency'] = widget.subscription['frequency'];
        petData['dogSize'] = widget.subscription['dogSize'];
        petData['mealPlan'] = widget.subscription['mealPlan'];
        
        return petData;
      } else {
        throw Exception('Pet data not found');
      }
    } catch (e) {
      throw Exception('Failed to fetch pet data: $e');
    }
  }

  /// Edit current meal
  void _editCurrentMeal() {
    if (currentMeal == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('No current meal found. Please generate a new meal first.'),
          backgroundColor: Colors.orange,
          action: SnackBarAction(
            label: 'Generate',
            textColor: Colors.white,
            onPressed: () {
              _generateNewMeal();
            },
          ),
        ),
      );
      return;
    }

    // Open the EditMealDialog from AI Meal Planner for consistent editing
    showDialog(
      context: context,
      builder: (context) => ai_meal.EditMealDialog(
        currentMealPlan: currentMeal!,
        petData: widget.userData,
        onMealEdited: (editedMeal) async {
          // Save edited meal to Firestore
          await FirebaseFirestore.instance
              .collection('meals')
              .doc(currentMeal!['id'])
              .update(editedMeal);
          setState(() {
            currentMeal = editedMeal;
            isEditingMeal = false;
          });
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('âœ… Meal updated successfully!'),
              backgroundColor: Colors.green,
            ),
          );
        },
      ),
    );
  }

  /// Navigate to edit pet details
  Future<void> _editPetDetails() async {
    try {
      // Show loading dialog
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => Center(
          child: Lottie.asset(
            'assets/Animations/AnimalcareLoading.json',
            width: 64,
            height: 64,
            fit: BoxFit.contain,
          ),
        ),
      );

      // Fetch pet data from Firestore using petId
      String userEmail = widget.userData['Email'] ?? widget.userData['uid'] ?? '';
      String petId = widget.subscription['petId'] ?? '';

      final petQuery = await FirebaseFirestore.instance
          .collection(userEmail)
          .where('Email', isEqualTo: petId)
          .get();
      if (petQuery.docs.isEmpty) {
        Navigator.of(context, rootNavigator: true).pop(); // Close loading
        throw Exception('Pet data not found');
      }
      final petData = petQuery.docs.first.data();

      Navigator.of(context, rootNavigator: true).pop(); // Close loading

      // Navigate to edit pet form
      final result = await Navigator.push(
        context,
        MaterialPageRoute(
          builder: (context) => EditPetForm(
            userData: widget.userData,
            petData: petData,
          ),
        ),
      );

      // If pet was updated, regenerate meal automatically
      if (result == true) {
        await _generateNewMealAfterPetUpdate();
      }
    } catch (e) {
      Navigator.of(context, rootNavigator: true).pop(); // Ensure loading is closed
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to open pet editor: $e'),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  /// Generate new meal after pet details update
  Future<void> _generateNewMealAfterPetUpdate() async {
    setState(() {
      isGeneratingMeal = true;
    });

    try {
      // Get updated pet data
      Map<String, dynamic> updatedPetData = await _getPetData();
      
      // Generate new meal with updated pet info
      Map<String, dynamic>? newMealData = await GeminiMealService.generateOptimalPersonalizedMealWithData(
        petData: updatedPetData,
      );

      if (newMealData != null && !newMealData.containsKey('error')) {
        // Save the new meal
        DocumentReference mealRef = await FirebaseFirestore.instance
            .collection('meals')
            .add({
          ...newMealData,
          'createdAt': DateTime.now().toIso8601String(),
          'subscriptionId': widget.subscription['id'],
          'petId': widget.subscription['petId'],
          'userId': widget.subscription['userId'],
          'generatedAfterPetUpdate': true,
        });

        // Update subscription with new meal ID
        await FirebaseFirestore.instance
            .collection('subscriptions')
            .doc(widget.subscription['id'])
            .update({
          'mealId': mealRef.id,
          'lastMealGenerated': DateTime.now().toIso8601String(),
        });

        // Reload current meal
        await _loadCurrentMeal();

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('âœ… Meal regenerated with updated pet info!'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Failed to regenerate meal: $e'),
          backgroundColor: Colors.red,
        ),
      );
    } finally {
      setState(() {
        isGeneratingMeal = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(
          'Manage Subscription',
          style: TextStyle(
            color: TextColor,
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
        ),
        backgroundColor: appBarColor,
        iconTheme: IconThemeData(color: TextColor),
        flexibleSpace: Container(
          decoration: BoxDecoration(gradient: listTileColorSecond),
        ),
      ),
      body: Container(
        width: double.infinity,
        height: double.infinity,
        decoration: BoxDecoration(gradient: backgroundColor),
        child: isLoading
            ? Center(
                child: Lottie.asset(
                  'assets/Animations/AnimalcareLoading.json',
                  width: 48,
                  height: 48,
                  fit: BoxFit.contain,
                ),
              )
            : SingleChildScrollView(
                physics: AlwaysScrollableScrollPhysics(),
                padding: EdgeInsets.all(16),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Subscription Info Card
                    _buildSubscriptionInfoCard(),
                    
                    SizedBox(height: 20),
                    
                    // Action Buttons
                    _buildActionButtons(),
                    
                    SizedBox(height: 20),
                    
                    // Current Meal Display
                    if (currentMeal != null && !isEditingMeal)
                      _buildCurrentMealDisplay(),
                    
                    // No Meal Placeholder
                    if (currentMeal == null && !isEditingMeal && !isGeneratingMeal)
                      _buildNoMealPlaceholder(),
                    
                    // Edit Meal Interface
                    if (isEditingMeal && currentMeal != null)
                      _buildEditMealInterface(),
                    
                    // Error Message
                    if (errorMessage != null)
                      Container(
                        width: double.infinity,
                        padding: EdgeInsets.all(16),
                        margin: EdgeInsets.symmetric(vertical: 8),
                        decoration: BoxDecoration(
                          color: Colors.red.shade50,
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(color: Colors.red.shade200),
                        ),
                        child: Text(
                          errorMessage!,
                          style: TextStyle(color: Colors.red.shade700),
                        ),
                      ),
                    
                    // Add bottom padding to ensure scrolling works properly
                    SizedBox(height: 100),
                  ],
                ),
              ),
      ),
    );
  }

  Widget _buildSubscriptionInfoCard() {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.all(20),
      decoration: BoxDecoration(
        gradient: LinearGradient(
          colors: [Colors.green.shade400, Colors.green.shade600],
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
        ),
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.green.withOpacity(0.3),
            blurRadius: 8,
            offset: Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Container(
                padding: EdgeInsets.all(8),
                decoration: BoxDecoration(
                  color: Colors.white.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(50),
                ),
                child: Text('ðŸ•', style: TextStyle(fontSize: 20)),
              ),
              SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      widget.subscription['petName'] ?? 'Unknown Pet',
                      style: TextStyle(
                        fontSize: 20,
                        fontWeight: FontWeight.bold,
                        color: Colors.white,
                      ),
                    ),
                    Text(
                      'Active Subscription',
                      style: TextStyle(
                        fontSize: 14,
                        color: Colors.white.withOpacity(0.9),
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
          SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: _buildInfoItem('Plan', widget.subscription['mealPlan'] ?? 'Unknown'),
              ),
              Expanded(
                child: _buildInfoItem('Frequency', widget.subscription['frequency'] ?? 'Unknown'),
              ),
            ],
          ),
          SizedBox(height: 8),
          Row(
            children: [
              Expanded(
                child: _buildInfoItem('Size', widget.subscription['dogSize'] ?? 'Unknown'),
              ),
              Expanded(
                child: _buildInfoItem('Price', 'à¸¿${widget.subscription['monthlyPrice']?.toStringAsFixed(2) ?? '0.00'}/month'),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildInfoItem(String label, String value) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: TextStyle(
            fontSize: 12,
            color: Colors.white.withOpacity(0.8),
          ),
        ),
        Text(
          value,
          style: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w600,
            color: Colors.white,
          ),
        ),
      ],
    );
  }

  Widget _buildActionButtons() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          'Meal Management',
          style: TextStyle(
            fontSize: 18,
            fontWeight: FontWeight.bold,
            color: TextColor,
          ),
        ),
        SizedBox(height: 12),
        // Generate New Meal Button
        Container(
          width: double.infinity,
          child: ElevatedButton.icon(
            onPressed: !isGeneratingMeal ? _generateNewMeal : null,
            icon: isGeneratingMeal 
                ? SizedBox(
                    width: 16,
                    height: 16,
                    child: Lottie.asset(
                      'assets/Animations/AnimalcareLoading.json',
                      width: 24,
                      height: 24,
                      fit: BoxFit.contain,
                    ),
                  )
                : Icon(Icons.auto_fix_high),
            label: Text(isGeneratingMeal ? 'Generating...' : 'Generate New Meal'),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.purple.shade400,
              foregroundColor: Colors.white,
              padding: EdgeInsets.symmetric(vertical: 14),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ),
        ),
        SizedBox(height: 12),
        Row(
          children: [
            Expanded(
              child: ElevatedButton.icon(
                onPressed: !isEditingMeal ? _editCurrentMeal : null,
                icon: Icon(Icons.edit),
                label: Text('Edit Current Meal'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: currentMeal != null ? Colors.blue.shade400 : Colors.grey.shade400,
                  foregroundColor: Colors.white,
                  padding: EdgeInsets.symmetric(vertical: 14),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
              ),
            ),
            SizedBox(width: 12),
            Expanded(
              child: ElevatedButton.icon(
                onPressed: _editPetDetails,
                icon: Icon(Icons.pets),
                label: Text('Edit Pet Details'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.orange.shade400,
                  foregroundColor: Colors.white,
                  padding: EdgeInsets.symmetric(vertical: 14),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(12),
                  ),
                ),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildCurrentMealDisplay() {
    if (currentMeal == null) return SizedBox.shrink();
    // Determine if Next Meal button should be enabled
    final subscriptionStatus = widget.subscription['status'] ?? 'pending';
    final isApproved = subscriptionStatus == 'approved';
    final isCancelled = subscriptionStatus == 'cancelled' || subscriptionStatus == 'admin_cancelled';
    final deliveryDateStr = widget.subscription['lastDeliveryDate'];
    DateTime? deliveryDate;
    if (deliveryDateStr != null) {
      try {
        deliveryDate = DateTime.parse(deliveryDateStr);
      } catch (_) {}
    }
    final now = DateTime.now();
    bool isLocked = false;
    if (deliveryDate != null) {
      final diff = now.difference(deliveryDate).inDays;
      // Lock if 1 day before, on, or 1 day after delivery
      if (diff >= -1 && diff <= 1) {
        isLocked = true;
      }
    }
    final canSendNextMeal = isApproved && !isCancelled && !isLocked;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // White card background like AI Meal Planner
        Container(
          width: double.infinity,
          padding: EdgeInsets.all(20),
          decoration: BoxDecoration(
            color: Colors.white,
            borderRadius: BorderRadius.circular(16),
            boxShadow: [
              BoxShadow(
                color: Colors.black12,
                blurRadius: 8,
                offset: Offset(0, 4),
              ),
            ],
          ),
          child: MealPlanDisplay(
            mealPlan: currentMeal!,
            petData: {
              'Name': widget.subscription['petName'] ?? widget.subscription['dogName'] ?? 'your pet',
              'petName': widget.subscription['petName'] ?? widget.subscription['dogName'] ?? 'your pet',
            },
          ),
        ),
        SizedBox(height: 16),
        // Full-width Next Meal button below the meal container
        Container(
          width: double.infinity,
          child: ElevatedButton.icon(
            onPressed: canSendNextMeal ? () async {
              // Send meal to order review for next cycle
              try {
                await FirebaseFirestore.instance.collection('order_review').add({
                  'meal': currentMeal,
                  'subscriptionId': widget.subscription['id'],
                  'userId': widget.subscription['userId'],
                  'petId': widget.subscription['petId'],
                  'requestedAt': DateTime.now().toIso8601String(),
                  'status': 'pending',
                  'frequency': widget.subscription['frequency'],
                });
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('Next meal sent to order review!'),
                    backgroundColor: Colors.green,
                  ),
                );
              } catch (e) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('Failed to send next meal: $e'),
                    backgroundColor: Colors.red,
                  ),
                );
              }
            } : null,
            icon: Icon(Icons.fast_forward),
            label: Text(isLocked
                ? 'Next Meal (Locked)'
                : !isApproved
                    ? 'Next Meal (Not Approved)'
                    : isCancelled
                        ? 'Next Meal (Subscription Cancelled)'
                        : 'Next Meal'),
            style: ElevatedButton.styleFrom(
              backgroundColor: canSendNextMeal ? Colors.purple.shade400 : Colors.grey.shade400,
              foregroundColor: Colors.white,
              padding: EdgeInsets.symmetric(vertical: 14),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ),
        ),
      ],
    );
  }

  void _showEditMealDialog() async {
    if (currentMeal == null) return;
    showDialog(
      context: context,
      builder: (context) => ai_meal.EditMealDialog(
        currentMealPlan: currentMeal!,
        petData: widget.userData,
        onMealEdited: (editedMeal) async {
          // Save edited meal to Firestore
          await FirebaseFirestore.instance
              .collection('meals')
              .doc(currentMeal!['id'])
              .update(editedMeal);
          setState(() {
            currentMeal = editedMeal;
            isEditingMeal = false;
          });
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('âœ… Meal updated successfully!'),
              backgroundColor: Colors.green,
            ),
          );
        },
      ),
    );
  }

  Widget _buildEditMealInterface() {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black12,
            blurRadius: 8,
            offset: Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.edit, color: Colors.blue.shade600),
              SizedBox(width: 8),
              Text(
                'Edit Meal Plan',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                  color: Colors.black87,
                ),
              ),
              Spacer(),
              TextButton(
                onPressed: () {
                  setState(() {
                    isEditingMeal = false;
                  });
                },
                child: Text('Cancel'),
              ),
            ],
          ),
          SizedBox(height: 16),
          // TODO: Implement meal editing interface
          // This would be similar to the AI Meal Planner's editing UI
          Text(
            'Meal editing interface would go here.\nThis would reuse the same UI components from the AI Meal Planner.',
            style: TextStyle(
              color: Colors.grey.shade600,
              fontStyle: FontStyle.italic,
            ),
          ),
          SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              ElevatedButton(
                onPressed: () {
                  // TODO: Implement actual meal saving logic
                  // For now, just close the edit interface
                  setState(() {
                    isEditingMeal = false;
                  });
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('âœ… Meal saved successfully! (Demo)'),
                      backgroundColor: Colors.green,
                    ),
                  );
                },
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.green.shade400,
                  foregroundColor: Colors.white,
                ),
                child: Text('Save Changes'),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildNoMealPlaceholder() {
    return Container(
      width: double.infinity,
      padding: EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black12,
            blurRadius: 8,
            offset: Offset(0, 4),
          ),
        ],
      ),
      child: Column(
        children: [
          Icon(
            Icons.restaurant_menu_outlined,
            size: 48,
            color: Colors.grey.shade400,
          ),
          SizedBox(height: 16),
          Text(
            'No Current Meal Plan',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
              color: Colors.grey.shade700,
            ),
          ),
          SizedBox(height: 8),
          Text(
            'Generate a personalized meal plan for your pet to get started.',
            textAlign: TextAlign.center,
            style: TextStyle(
              fontSize: 14,
              color: Colors.grey.shade600,
            ),
          ),
          SizedBox(height: 16),
          ElevatedButton.icon(
            onPressed: _generateNewMeal,
            icon: Icon(Icons.auto_fix_high),
            label: Text('Generate Meal Plan'),
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.purple.shade400,
              foregroundColor: Colors.white,
              padding: EdgeInsets.symmetric(horizontal: 24, vertical: 12),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(10),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// Helper widget to wrap the AI meal display for use in ManageSubscriptionScreen
class AIMealPlanMealDisplay extends StatelessWidget {
  final Map<String, dynamic> mealPlan;
  final Map<String, dynamic> petData;
  final VoidCallback? onEdit;
  const AIMealPlanMealDisplay({
    Key? key,
    required this.mealPlan,
    required this.petData,
    this.onEdit,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Use the AI Meal Planner's display widget
        // (You may need to copy _buildJSONMealPlanDisplay to a shared location if it's private)
        // For now, just show a placeholder:
        Text('AI Meal Plan Display (replace with actual widget)'),
        // TODO: Replace with actual _buildJSONMealPlanDisplay logic
        if (onEdit != null)
          Align(
            alignment: Alignment.centerRight,
            child: ElevatedButton.icon(
              onPressed: onEdit,
              icon: Icon(Icons.edit),
              label: Text('Edit Meal'),
            ),
          ),
      ],
    );
  }
}
