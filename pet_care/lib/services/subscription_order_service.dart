import 'package:cloud_firestore/cloud_firestore.dart';

class SubscriptionOrderService {
  static final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  /// Creates the first immediate order when subscription is approved
  /// Marks it as Urgent with no due date
  static Future<Map<String, dynamic>> createImmediateOrderFromSubscription(
    String subscriptionId, 
    Map<String, dynamic> subscriptionData,
    DateTime approvalTime
  ) async {
    try {
      String orderId = FirebaseFirestore.instance.collection('orders').doc().id;
      
      // Get next order number
      int orderNumber = await _getNextOrderNumber();
      
      // Get customer name using the proper method
      String customerName = await _getCustomerName(subscriptionData['userId']);

      // Create immediate order data
      Map<String, dynamic> orderData = {
        'orderId': orderId,
        'orderNumber': orderNumber, // Permanent order number
        'subscriptionId': subscriptionId,
        'userId': subscriptionData['userId'],
        'petId': subscriptionData['petId'],
        'petName': subscriptionData['petName'],
        'dogName': subscriptionData['dogName'] ?? subscriptionData['petName'],
        'customerName': customerName,
        
        // Order status and timing
        'status': 'pending',
        'priority': 'urgent', // First meal is urgent
        'orderType': 'subscription_meal',
        'orderSequence': 1, // Track order sequence
        'cycleNumber': 1, // Track delivery cycle
        
        // Timestamps
        'createdAt': DateTime.now().toIso8601String(),
        'subscriptionApprovedAt': approvalTime.toIso8601String(),
        'orderDate': DateTime.now().toIso8601String(),
        'scheduledDeliveryDate': '', // No due date for urgent orders
        'dueDate': '', // No due date for first meal
        'urgentDeadline': DateTime.now().add(Duration(hours: 24)).toIso8601String(), // 24h prep time
        
        // Meal and subscription info
        'mealPlan': subscriptionData['mealPlanDetails'] ?? subscriptionData['mealPlan'],
        'dogSize': subscriptionData['dogSize'],
        'frequency': subscriptionData['frequency'],
        'specialInstructions': _generateSpecialInstructions(subscriptionData),
        
        // Delivery information
        'deliveryLocation': subscriptionData['deliveryLocation'] ?? {},
        'deliveryAddress': subscriptionData['deliveryLocation']?['address'] ?? '',
        'deliveryLatitude': subscriptionData['deliveryLocation']?['latitude'] ?? 0.0,
        'deliveryLongitude': subscriptionData['deliveryLocation']?['longitude'] ?? 0.0,
        'deliveryCity': subscriptionData['deliveryLocation']?['city'] ?? '',
        
        // Order lifecycle timestamps
        'preparationStartedAt': '',
        'preparationCompletedAt': '',
        'readyForDeliveryAt': '',
        'dispatchedAt': '',
        'deliveredAt': '',
        
        // Financial
        'totalAmount': subscriptionData['totalAmount'] ?? 0.0,
        'notes': 'First subscription delivery - URGENT',
        
        // Lock status for meal editing
        'mealLocked': false, // Initially unlocked until preparation starts
        'lockReason': '',
        
        // Auto-generation flags
        'isAutoGenerated': false, // First meal is manual
        'nextOrderScheduled': false,
      };
      
      // Save to Firestore
      await _firestore.collection('orders').doc(orderId).set(orderData);
      
      // Update subscription with first order info
      await _firestore.collection('subscriptions').doc(subscriptionId).update({
        'firstOrderId': orderId,
        'firstOrderCreatedAt': DateTime.now().toIso8601String(),
        'currentCycle': 1,
        'lastDeliveryDate': '',
        'nextScheduledDelivery': '',
        'status': 'active', // Change status to active once first order is created
      });
      
      return {
        'success': true,
        'orderId': orderId,
        'message': 'Immediate order created successfully'
      };
      
    } catch (e) {
      return {
        'success': false,
        'error': e.toString(),
        'message': 'Failed to create immediate order'
      };
    }
  }

  /// Schedules the next recurring order based on frequency and delivery timing
  static Future<Map<String, dynamic>> scheduleNextRecurringOrder({
    required String subscriptionId,
    required DateTime lastDeliveryTime,
    required String frequency,
    required int currentCycle,
  }) async {
    try {
      // Calculate next delivery date based on frequency
      DateTime nextDeliveryDate = _calculateNextDeliveryDate(lastDeliveryTime, frequency);
      DateTime criticalDate = _calculateCriticalDate(lastDeliveryTime, frequency);
      
      // Fetch subscription data
      DocumentSnapshot subscriptionDoc = await _firestore
          .collection('subscriptions')
          .doc(subscriptionId)
          .get();
      
      if (!subscriptionDoc.exists) {
        throw Exception('Subscription not found');
      }
      
      Map<String, dynamic> subscriptionData = subscriptionDoc.data() as Map<String, dynamic>;
      
      // Generate unique order ID
      String orderId = 'ORD_${DateTime.now().millisecondsSinceEpoch}_${subscriptionId.hashCode.abs()}_${currentCycle + 1}';
      
      // Get next order number
      int orderNumber = await _getNextOrderNumber();
      
      // Get customer name
      String customerName = await _getCustomerName(subscriptionData['userId']);
      
      // Create next order data
      Map<String, dynamic> orderData = {
        'orderId': orderId,
        'orderNumber': orderNumber, // Permanent order number
        'subscriptionId': subscriptionId,
        'userId': subscriptionData['userId'],
        'petId': subscriptionData['petId'],
        'petName': subscriptionData['petName'],
        'dogName': subscriptionData['dogName'] ?? subscriptionData['petName'],
        'customerName': customerName,
        
        // Order status and timing
        'status': 'pending',
        'priority': 'normal', // Regular orders start as normal
        'orderType': 'subscription_meal',
        'orderSequence': currentCycle + 1,
        'cycleNumber': currentCycle + 1,
        
        // Timestamps
        'createdAt': DateTime.now().toIso8601String(),
        'orderDate': DateTime.now().toIso8601String(),
        'scheduledDeliveryDate': nextDeliveryDate.toIso8601String(),
        'dueDate': nextDeliveryDate.toIso8601String(),
        'criticalDate': criticalDate.toIso8601String(), // When it becomes critical
        
        // Meal and subscription info (same meal unless updated)
        'mealPlan': subscriptionData['mealPlanDetails'] ?? subscriptionData['mealPlan'],
        'dogSize': subscriptionData['dogSize'],
        'frequency': subscriptionData['frequency'],
        'specialInstructions': _generateSpecialInstructions(subscriptionData),
        
        // Delivery information
        'deliveryLocation': subscriptionData['deliveryLocation'] ?? {},
        'deliveryAddress': subscriptionData['deliveryLocation']?['address'] ?? '',
        'deliveryLatitude': subscriptionData['deliveryLocation']?['latitude'] ?? 0.0,
        'deliveryLongitude': subscriptionData['deliveryLocation']?['longitude'] ?? 0.0,
        'deliveryCity': subscriptionData['deliveryLocation']?['city'] ?? '',
        
        // Order lifecycle timestamps
        'preparationStartedAt': '',
        'preparationCompletedAt': '',
        'readyForDeliveryAt': '',
        'dispatchedAt': '',
        'deliveredAt': '',
        
        // Financial
        'totalAmount': subscriptionData['totalAmount'] ?? 0.0,
        'notes': 'Recurring subscription delivery - Cycle ${currentCycle + 1}',
        
        // Lock status for meal editing
        'mealLocked': false,
        'lockReason': '',
        
        // Auto-generation flags
        'isAutoGenerated': true,
        'nextOrderScheduled': false,
      };
      
      // Save to Firestore
      await _firestore.collection('orders').doc(orderId).set(orderData);
      
      // Update subscription with next order info
      await _firestore.collection('subscriptions').doc(subscriptionId).update({
        'currentCycle': currentCycle + 1,
        'nextScheduledDelivery': nextDeliveryDate.toIso8601String(),
        'lastOrderId': orderId,
        'lastOrderCreatedAt': DateTime.now().toIso8601String(),
      });
      
      return {
        'success': true,
        'orderId': orderId,
        'nextDeliveryDate': nextDeliveryDate.toIso8601String(),
        'message': 'Next recurring order scheduled successfully'
      };
      
    } catch (e) {
      return {
        'success': false,
        'error': e.toString(),
        'message': 'Failed to schedule next recurring order'
      };
    }
  }

  /// Updates order priority to critical when due date is reached
  static Future<void> updateOrdersToCritical() async {
    try {
      DateTime now = DateTime.now();
      
      // Query orders that should become critical
      QuerySnapshot ordersQuery = await _firestore
          .collection('orders')
          .where('status', whereIn: ['pending'])
          .where('priority', isEqualTo: 'normal')
          .get();
      
      WriteBatch batch = _firestore.batch();
      int updatedCount = 0;
      
      for (QueryDocumentSnapshot doc in ordersQuery.docs) {
        Map<String, dynamic> data = doc.data() as Map<String, dynamic>;
        
        // Check if critical date has passed
        String criticalDateStr = data['criticalDate'] ?? '';
        if (criticalDateStr.isNotEmpty) {
          try {
            DateTime criticalDate = DateTime.parse(criticalDateStr);
            if (now.isAfter(criticalDate)) {
              batch.update(doc.reference, {
                'priority': 'critical',
                'priorityUpdatedAt': now.toIso8601String(),
                'notes': '${data['notes'] ?? ''}\n‚ö†Ô∏è Order became CRITICAL on ${now.toIso8601String()}',
              });
              updatedCount++;
            }
          } catch (e) {
            print('Error parsing critical date for order ${doc.id}: $e');
          }
        }
      }
      
      if (updatedCount > 0) {
        await batch.commit();
        print('Updated $updatedCount orders to critical priority');
      }
      
    } catch (e) {
      print('Error updating orders to critical: $e');
    }
  }

  /// Locks meal for editing when order enters preparation stage
  static Future<Map<String, dynamic>> lockMealForPreparation(String orderId) async {
    try {
      await _firestore.collection('orders').doc(orderId).update({
        'mealLocked': true,
        'lockReason': 'Your meal is being prepared. Changes will apply to the next delivery.',
        'preparationStartedAt': DateTime.now().toIso8601String(),
      });
      
      return {
        'success': true,
        'message': 'Meal locked for preparation'
      };
    } catch (e) {
      return {
        'success': false,
        'error': e.toString(),
        'message': 'Failed to lock meal'
      };
    }
  }

  /// Unlocks meal and applies pending changes to future orders
  static Future<Map<String, dynamic>> unlockMealAndApplyChanges({
    required String orderId,
    required String subscriptionId,
    Map<String, dynamic>? newMealPlan,
  }) async {
    try {
      // Update completed order
      await _firestore.collection('orders').doc(orderId).update({
        'mealLocked': false,
        'lockReason': '',
        'deliveredAt': DateTime.now().toIso8601String(),
      });
      
      // If there are meal changes, apply to subscription and future orders
      if (newMealPlan != null) {
        // Update subscription with new meal plan
        await _firestore.collection('subscriptions').doc(subscriptionId).update({
          'mealPlanDetails': newMealPlan,
          'mealUpdatedAt': DateTime.now().toIso8601String(),
        });
        
        // Update any pending future orders that aren't locked
        QuerySnapshot futureOrders = await _firestore
            .collection('orders')
            .where('subscriptionId', isEqualTo: subscriptionId)
            .where('status', whereIn: ['pending'])
            .where('mealLocked', isEqualTo: false)
            .get();
        
        WriteBatch batch = _firestore.batch();
        for (QueryDocumentSnapshot doc in futureOrders.docs) {
          batch.update(doc.reference, {
            'mealPlan': newMealPlan,
            'mealUpdatedAt': DateTime.now().toIso8601String(),
            'notes': '${(doc.data() as Map<String, dynamic>)['notes'] ?? ''}\nüîÑ Meal updated by user',
          });
        }
        
        if (futureOrders.docs.isNotEmpty) {
          await batch.commit();
        }
      }
      
      return {
        'success': true,
        'message': 'Meal unlocked and changes applied to future orders'
      };
    } catch (e) {
      return {
        'success': false,
        'error': e.toString(),
        'message': 'Failed to unlock meal and apply changes'
      };
    }
  }

  /// Gets orders sorted by due date and priority
  static Stream<QuerySnapshot> getOrdersSortedByPriority() {
    return _firestore
        .collection('orders')
        .where('status', whereIn: ['pending', 'preparing'])
        .snapshots();
  }

  /// Check if meal can be edited (not locked for preparation)
  static Future<Map<String, dynamic>> checkMealEditability(String orderId) async {
    try {
      DocumentSnapshot orderDoc = await _firestore
          .collection('orders')
          .doc(orderId)
          .get();
      
      if (!orderDoc.exists) {
        return {
          'canEdit': false,
          'reason': 'Order not found'
        };
      }
      
      Map<String, dynamic> data = orderDoc.data() as Map<String, dynamic>;
      bool isLocked = data['mealLocked'] ?? false;
      String status = data['status'] ?? 'pending';
      
      if (isLocked || ['preparing', 'ready', 'on_way', 'delivered'].contains(status)) {
        return {
          'canEdit': false,
          'reason': data['lockReason'] ?? 'Your meal is being prepared. Changes will apply to the next delivery.'
        };
      }
      
      return {
        'canEdit': true,
        'reason': ''
      };
    } catch (e) {
      return {
        'canEdit': false,
        'reason': 'Error checking meal editability: $e'
      };
    }
  }

  // Helper methods
  static DateTime _calculateNextDeliveryDate(DateTime lastDelivery, String frequency) {
    switch (frequency) {
      case '1x/week':
      case '1x per week':
        return lastDelivery.add(Duration(days: 7));
      case '2x/week':
      case '2x per week':
        return lastDelivery.add(Duration(days: 3));
      default:
        return lastDelivery.add(Duration(days: 7));
    }
  }

  static DateTime _calculateCriticalDate(DateTime lastDelivery, String frequency) {
    switch (frequency) {
      case '1x/week':
      case '1x per week':
        return lastDelivery.add(Duration(days: 5)); // Critical after 5 days
      case '2x/week':
      case '2x per week':
        return lastDelivery.add(Duration(days: 3)); // Critical after 3 days
      default:
        return lastDelivery.add(Duration(days: 5));
    }
  }

  static Future<String> _getCustomerName(String? userId) async {
    if (userId == null || userId.isEmpty) return 'Unknown Customer';
    
    try {
      final userDoc = await _firestore
          .collection('UserData')
          .doc(userId)
          .get();
      
      if (userDoc.exists) {
        final userData = userDoc.data() as Map<String, dynamic>;
        return userData['Name'] ?? 'Unknown Customer';
      }
    } catch (e) {
      print('Error fetching customer name: $e');
    }
    
    return 'Unknown Customer';
  }

  static String _generateSpecialInstructions(Map<String, dynamic> subscriptionData) {
    List<String> instructions = [];
    
    final allergies = List<String>.from(subscriptionData['foodAllergies'] ?? []);
    if (allergies.isNotEmpty) {
      instructions.add('‚ö†Ô∏è ALLERGIES: Avoid ${allergies.join(", ")}');
    }
    
    final healthGoals = List<String>.from(subscriptionData['healthGoals'] ?? []);
    if (healthGoals.isNotEmpty) {
      instructions.add('üéØ GOALS: Focus on ${healthGoals.join(", ")}');
    }
    
    final activityLevel = subscriptionData['activityLevel'] ?? '';
    if (activityLevel.isNotEmpty) {
      instructions.add('üí™ ACTIVITY: ${activityLevel} energy requirements');
    }
    
    final weight = subscriptionData['weight'] ?? '';
    final weightUnit = subscriptionData['weightUnit'] ?? 'kg';
    if (weight.toString().isNotEmpty) {
      instructions.add('‚öñÔ∏è WEIGHT: ${weight}${weightUnit} - adjust portions accordingly');
    }
    
    return instructions.join('\n');
  }

  /// Gets the next order number from Firestore counter
  static Future<int> _getNextOrderNumber() async {
    try {
      final counterRef = _firestore.collection('counters').doc('orderNumber');
      
      return await _firestore.runTransaction<int>((transaction) async {
        final counterDoc = await transaction.get(counterRef);
        
        int newOrderNumber;
        if (counterDoc.exists) {
          int currentNumber = counterDoc.data()?['value'] ?? 0;
          newOrderNumber = currentNumber + 1;
        } else {
          newOrderNumber = 1; // Start from 1 for first order
        }
        
        // Update the counter
        transaction.set(counterRef, {'value': newOrderNumber}, SetOptions(merge: true));
        
        return newOrderNumber;
      });
    } catch (e) {
      print('Error getting next order number: $e');
      // Fallback: use timestamp-based number
      return DateTime.now().millisecondsSinceEpoch % 100000;
    }
  }
}
